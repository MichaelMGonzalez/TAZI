\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{natbib}

\begin{document}
\author{Hannah Chu, Priyanka Kulshreshtha, Michael Gonzalez and Paula Quach}
\title{Gadgetron Project Proposal}
\maketitle

\section{Research Context and Problem Statement}
Our research focuses on automating the process of building gadgets through the project called Gadgetron, performed in various steps through a tool-chain. Gadgetron's current focus is the automation of design by providing users a visual platform to design their desired electronic gadget. It then generates the appropriate files necessary to print out the circuit board, a process easily performed by sending the files off to any PCB company. Gadgetron has greatly reduced the limitations, making it possible to design and build a gadget without requiring extensive electrical engineering knowledge. The automation of circuit-building both for gadgets and other electronics has been and is still being vastly explored in research in regards to rapid prototyping. While Gadgetron may appear to be just another part of that bandwagon, it will advance further than just automating and accelerating the process of building the hardware.
\subsection{Problem Statement}
The learning curve for building gadgets can be very high. A person of any age could have an idea for a gadget, whether it be a small one for a hobby or a brilliant one that could change the world. However, in order to make their dreams a reality, they must learn circuits, capacitors, and resistors to implement the idea. Not only that, but the maker must learn to code in order to control their device to do what they envisioned. Of the past research that has been done, the focus has usually been on one side (hardware) or the other (software). For instance, the creation of electronics has been improved through research on rapid prototyping like circuits that shrink for flexibility\cite{shrinky} and printed circuits\cite{inkjets}. On the other hand, improving the coding learning curve has been explored in visual programming languages like Snap or UUistle which focused specifically on computer science education\cite{UUistle}. Gadgetron must address these needs, so it must become more universal and cater to a larger audience. \\[7pt]

\section{Proposed Solution}
Gadgetron so far has only covered the hardware part of automation. Our plan is to expand on the Code Generation Framework that was started by a graduate student, Alexander Caughron, in order to extend Gadgetron to greatly simplify the process of writing code for the gadgets it builds. We would like to take this automation one step further and provide a framework to automatically generate the appropriate code for Gadgetron users to easily control what they build. Thus, users would not be required to learn an entire programming language and its syntax in order to make their gadget do what they want; they can just use Gadgetron's automated code generation to program the gadget as they would like. We believe that this a necessary step to achieve Gadgetron's overall goal. Adding this piece will reduce the constraints even further and enable individuals with very little technical knowledge to make working gadgets. All a user would need to do is design and assemble it, and even the latter may be easily achieved with some out-of-scope plans to adapt Gadgetron to generate building instructions for the user. Our focus, however, will be on the visual code-generation aspect of Gadgetron.\\[7pt]

To do this, we plan to create a visual-based language that will enable users to outline how their gadget should function. The program will then generate the necessary code that is compatible with the gadget made using Gadgetron's web tool. Perhaps the most successful model of this type is the LEGO Mindstorms model, which allows users to program their robot by using the accompanying Intelligence Brick. Although the kit claims to give users full freedom on how to design their robot, they have a constraint in the form of the I-Brick [3]. No matter what designs they choose, that large block must be included. Conversely, Gadgetron does not have any such constraint and truly gives the user the unique experience of designing a robot according to their preferences.\\[7pt]

There have also been a few attempts at creating something similar to our proposed solution. One such system was the visual robot programming for generalizable mobile manipulation tasks project at the University of Washington. Their goal was to make a product, called RoboFlow, that could replace traditional coding when it came to programming robots[2]. However, the key difference between RoboFlow and Gadgetron is usability. The format of Gadgetron's Code Generation Framework is dedicated towards providing the easiest way to program robots without having to know much about the process itself. This is in contrast to RoboFlow, in which you do need to have a basic understanding of hardware engineering. Again, Gadgetron would remove this limitation, making the tool more universal.\\[7pt]

With our project added to Gadgetron, it will become easy to use for any age group, as it will require very little prior knowledge. We can introduce the process of creating gadgets at an early age, which can also motivate students to pursue it in the future. Previous trials of similar works have involved using LEGO MindStorms to teach groups of junior high students about robotics\cite{legomindstorms}. With the levels of abstraction that Gadgetron provides, students will be able to start learning robotics as early as elementary school. It can add to the existing curriculum at lower levels and include a thought-provoking discipline outside of the usual math, science, history, etc.\\[7pt]

Gadgetron is already a novel project in that it attempts to largely automate such a complex process. Combined with the Code Generation Framework, Gadgetron will become one of the easiest ways to create a working gadget. It will aid in teaching kids about engineering from an early age as well as fully automate the gadget-building process for anyone who would like to build something for themselves.


\section{Evaluation and Implementation Plan}
How will you know if your research was successful?  And how will you organize your work to get it done in the time you have?

\subsection{Evaluation Plan}
Our project will most likely stay in the early stages of development, but should we complete our solution within the time frame, we have several options open to us in order to test our work. Maybe even further down the line, we could develop our own metrics to evaluate our success, but for now, our methods will have to cover two modes of evaluation:\\[7pt]

First and foremost, we can evaluate the solution in terms of correctness, in that it actually works as intended. As we plan to use our visual language to correctly control gadgets built off of Gadgetron, we can ensure our success by simply testing it ourselves and with other experienced members of Gadgetron. Modular testing of each component separately and subsequently in groups like an average gadget can ensure that most controls function as planned.\\[7pt]

Next, and more difficult, are our plans for evaluating whether visual programming makes programming electronic gadgets easier for new users. We must test how intuitive our language is to learn and how it compares to Arduino's C-like programming language. To get a sense of how our language compares, we plan to give two experiment groups a simple simulated robotics programming task: program their robot to drive in a square path. We would provide the participants a web application in which they could control their robot simulation. One group would interact with the simulation using our visual-based programming methods, while the other group would interact with the simulation by writing C code. Both groups would receive applicable instruction on how to accomplish their task. We will measure the time it takes to complete each section (IE: Reading the task, implementing a solution, finding a correct implementation). We will examine how much more quickly our visual language helps users acclimate to using Gadgetron and perhaps also compare levels of knowledge required to use the differing tools.

\subsection{Timeline}
Initially, our plan will involve establishing a firm understanding of similar works: Snap, Scratch, and maybe others. After that, we will start by either modifying their frameworks or converting Alexander Caughron's for our own purposes. Once we have a solid base, we will then integrate that framework into Gadgetron, then start building from our base framework to include all the components available to Gadgetron so that the user can actually create a program that correctly controls the gadget. We do not plan on finishing this early as the task is rather complicated, so our evaluation plan will likely take place during the spring. However, throughout our work on adding component controls, we will be consistently testing the correctness of our work through programming gadgets.

\bibliographystyle{plain}
\bibliography{gadgetronprop}
\end{document}