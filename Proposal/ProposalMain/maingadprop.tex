\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{natbib}

\begin{document}
\author{Hannah Chu, Priyanka Kulshreshtha, Michael Gonzalez and Paula Quach}
\title{Gadgetron Project Proposal}
\maketitle

\section{Research Context and Problem Statement}
A quick internet search reveals thousands of ideas and questions that various people have for gadgets that they'd love to use or make. Some hobbyists have succeeded in actually creating those ideas and indeed, current technology can be counted as just extremely successful gadget ideas. However, that success largely hinges on factors that limit the general public from creating their own desires. In order for a gadget to be built, the creator would need knowledge of two main things: circuits and programming. Both require lots of time and sometimes even money to learn.\\[7pt]
The automation of circuit-building both for gadgets and other electronics has been and is still being vastly explored in research in regards to rapid prototyping. For instance, the creation of electronics has been improved through research on rapid prototyping like circuits that shrink for flexibility\cite{shrinky} and printed circuits\cite{inkjets}. Our research focuses on automating the process of building gadgets through the project called Gadgetron. Gadgetron's current focus is the automation of design by providing users a visual platform to design their desired electronic gadget. A user can simply drag and drop their components on a web-tool. Gadgetron's tool-chain infers where electrical connections must be made and generates the CAM files necessary to print out the circuit board, a process easily performed by sending the files off to a PCB manufacturing company. Gadgetron greatly reduces the academic prerequisites to build electronic gadgets - making it possible to design and build a gadget without requiring extensive electrical engineering knowledge. Additionally, we have found gadgets (particularly miniature robots) made through Gadgetron are generally cheaper than commercially available products.\\[7pt]
On the other hand, Gadgetron does not address the creator's need to program the gadget that it creates so any user will need to learn programming on their own to actually implement their work. For a child (or even an adult!) the learning curve for programming anything, let alone gadgets, can be very high. In general, programmers have to learn a programming language, good style, and numerous paradigms to make their program work. This daunting list deters some users from ever considering learning the subject thus stopping gadget-building in its tracks. 
\subsection{Problem Statement}
We believe Gadgetron must address novice programming challenges so more users can not only build a gadget, but make their gadget work. Even if a gadget-maker is able to easily create the physical body of what they need, it still requires knowledge to make it perform to their actual desired implementation because the parts won't work unless told so. To program gadgets, gadget-makers must not only learn the language but they'll also have to work under the additional constraints of programming an embedded system. We normally have to work with a very limited amount of memory, with low level programming languages, and with dense technical documentation for libraries. This may deter many people and may even specifically end the simple ideas of younger children. Thus, Gadgetron should also provide an easy-to-use interface for users to control the creations that it creates.
\subsection {Related Work} 
To address these issues, Computer Science Education researchers have exerted a considerable amount of effort into developing new practices to improve programming pedagogy and students' own perceived ability to succeed within our field. The development of specialized visual programming tools have been shown to aid novice programmers\cite{UUhistle}\cite{greenfoot}\cite{CS1forScientists}. For example, UUhistle, an interactive program simulator, allows students to visualize their code step-by-step so they may quickly overcome common programming misconceptions.\cite{UUhistle} Turtle graphics suites create simulated worlds where students program a turtle's movement. The suites' simple functions coupled with instruction teach concepts like sequential code execution and recursion.\cite{greenfoot}\cite{CS1forScientists} While environments like these do an excellent job illustrating paradigms in the presence of a skilled instructor, they leave the learner alone to wrestle with the syntax of a language. Visual based languages like Scratch and Snap give users an online programming play-place to create simple games, animations, and songs. These languages prevent users from creating syntacticly incorrect programs all together. Users writing in Scratch or Snap may only connect blocks(a feature akin to functions) with another block if the resulting program is syntactically valid.\cite{Scratch}\\[7pt]
 In a related pedagogical vein, curricula designed around programming robots help serve as an introduction to embedded systems programming and help improve students' interest in Computer Science.\cite{PersonalizingCS1}\cite{RobotMotivation}\cite {elementaryRobots}\cite{cRobots}\cite{primarySchool} Most of said courses teach lower level languages to program the robots. However, several studies have used Lego Mindstorms, a modular robotics kit, and its accompanying visual programming language.\cite{legomindstorms}\cite{legomindstorms2} Lego Mindstorms provides an easy to use interface to allow its users to program their robots; however, it limits them by a relatively high price of the kit and to the Lego platform.

\section{Proposed Solution}
 We believe the creation of a specialized visual development environment for Gadgetron will make programming gadgets accessible to more people. This environment will hide most of the low-level and error prone parts of programming from the user. We plan to incorporate this through 3 majors modules: a schematic parser, a visual based programming language, and a code generator. The schematic parser will infer connections between the micro-controller and the gadget's components, build a list of all the attached components, and remember where all the digital and analog pins connect. Our environment will use this information to give users a subset of our visual programming language, a heavily modified version of Snap. We will keep several of the control flow blocks that Snap provides; but, we will replace the majority of the blocks with our own. These special blocks will correspond to functions associated with the gadget's attached components. Finally, the code generator will use information from the previous 2 modules to create valid C++ code that the user can upload to their gadget. This generator will automatically include any required libraries, instantiate any objects the program needs, and map the blocks to their original functions. Thus, users would not be required to learn low-level programming and syntax in order to make their gadget do what they want; they can just use Gadgetron's visual development environment to program the gadget as they like. We believe that this a necessary step to achieve Gadgetron's overall goal. Adding this piece will reduce the constraints even further and enable individuals with very little technical knowledge to make working gadgets. All a user would need to do is design and assemble it, and even the latter may be easily achieved with some out-of-scope plans to adapt Gadgetron to generate building instructions for the user. \\[7pt]
With our project added to Gadgetron, it will become easy to use for any age group, as it will require very little prior knowledge. We can introduce the process of creating gadgets at an early age, which may also motivate students to pursue it in the future. With the levels of abstraction that Gadgetron provides, students will be able to start learning robotics as early as elementary school. It can add to the existing curriculum at lower levels and include a thought-provoking discipline outside of the usual math, science, history, etc.\\[7pt]
Gadgetron is already a novel project in that it attempts to largely automate such a complex process. Combined with the Code Generation Framework, Gadgetron will become one of the easiest ways to create a working gadget. It will aid in teaching kids about engineering from an early age as well as fully automate the gadget-building process for anyone who would like to build something for themselves.


\section{Evaluation and Implementation Plan}

\subsection{Evaluation Plan}
Our project will most likely stay in the early stages of development; however, we have two planned methods to evaluate our work:\\[7pt]
First and foremost, we can evaluate the solution in terms of correctness, in that it actually works as intended. As we plan to use our visual language to correctly control gadgets built off of Gadgetron, we can ensure our success by simply testing it ourselves and with other experienced members of Gadgetron. Modular testing of each component separately and subsequently in groups like an average gadget can ensure that most controls function as planned.\\[7pt]
Next, and more difficult, are our plans for evaluating whether visual programming makes programming electronic gadgets easier for new users. We must test how intuitive our language is to learn and how it compares to Arduino's C-like programming language. To get a sense of how our language compares, we plan to give two experiment groups a simple simulated robotics programming task: program their robot to drive in a square path. We would provide the participants a web application in which they could control their robot simulation. One group would interact with the simulation using our visual-based programming methods, while the other group would interact with the simulation by writing C code. Both groups would receive applicable instruction on how to accomplish their task. We will measure the time it takes to complete each section (IE: Reading the task, implementing a solution, finding a correct implementation). We will examine how much more quickly our visual language helps users acclimate to using Gadgetron and perhaps also compare levels of knowledge required to use the differing tools.

\subsection{Timeline}
Initially, our plan will involve establishing a firm understanding of similar works: Snap, Scratch, and maybe others. Once we have a solid base, we will then integrate that framework into Gadgetron, then start building from our base framework to include all the components available to Gadgetron so that the user can actually create a program that correctly controls the gadget. We do not plan on finishing this early as the task is rather complicated, so our evaluation plan will likely take place during the spring. However, throughout our work on adding component controls, we will be consistently testing the correctness of our work through programming gadgets.

\bibliographystyle{plain}
\bibliography{gadgetronprop}
\end{document}